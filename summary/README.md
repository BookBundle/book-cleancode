## 목차

- [2장. 의미 있는 이름](#1)
- [3장. 함수](#2)
- [4장. 주석](#3)
- [5장. 형식 맞추기](#4)
- [6장. 객체와 자료 구조](#5)
- [7장. 오류 처리](#6)
- [8장. 경계](#7)
- [9장. 단위 테스트](#8)
- [10장. 클래스](#9)
- [11장. 시스템](#10)
- [12장. 창발성](#11)
- [13장. 동시성](#12)

## <a name = '1'> 2장. 의미 있는 이름 </a>

- 문장이나 문단처럼 읽히는 코드 혹은 자료 구조처럼 읽히는 코드를 작성한다.  
- 변수의 존재 이유, 기능, 사용 방법이 드러나도록 의도를 분명히 밝힌다. 중의적으로 해석될 여지가 있거나 특수한 의미를 지니는 단어는 변수명에 붙이지 않는다.  
- 검색하기 쉬운 이름을 사용하며, 인코딩과 헝가리식 표기법을 피하도록 한다.  
- 코드를 읽는 사람이 한 번 더 생각해야 하는 변수명을 사용하지 않는다. 특정 문화에서만 사용되거나, 재미있는 이름보다는 _명료한 이름_ 을 사용한다.
- 클래스 이름은 명사 혹은 명사구를, 메서드 이름은 동사 혹은 동사구를 사용한다.  
- 똑같은 메서드를 클래스마다 다르게 사용하거나 말장난을 하지 않는다.  
- 해법 영역 혹은 문제 영역에서 이름을 가져온다.  
- 불필요한 맥락은 제거하고, 의미 있는 맥락(접두어 등)을 추가하여 맥락을 좀 더 분명하게 한다.  

## <a name = '2'> 3장. 함수 </a>

- 함수는 최대한 작게 만들며, 한 가지 기능을 하도록 한다.  
- 코드 블록은 한 줄이 좋으며, 들여쓰기 수준이 2단을 넘지 않도록 한다.  
- 함수 당 추상화 수준은 하나로 통일한다.  
- 함수 이름은 서술적인 이름을 사용하고, 가장 이상적인 인수는 무항이나, 인수를 써야 한다면 1~2개까지가 적당하다.  
- 오류/예외도 하나의 기능이므로 분리하도록 한다.  
- 위에서 아래로 읽히도록 하며 중복을 없애도록 지속적으로 노력한다.

## <a name = '3'> 4장. 주석 </a>

- **주석을 달기보다는 코드로 의미를 표현하는 것이 가장 좋다.**
- 변경 이력을 남기는 것은 구시대적인 방식이고 이제는 버전 관리 시스템에 맡기자.
- 소스 코드의 의도를 표현하거나 의미를 보다 명확하게 해주는 주석은 좋다.
- 독자가 별생각 없이 코드를 변경할 위험성이 있는 곳에는 주석으로 경고하거나 중요성을 강조하는 주석을 넣어도 좋다.
- TODO 주석은 지금 할 일을 나중으로 미루는 것으로 바로바로 해결하거나 없애도록 하자.
- 주석이 같은 말을 반복하고, 오해할 여지가 있거나 의무적으로 다는 주석들은 안다는 것만도 못하기에 지워버리자.

## <a name = '4'> 5장. 형식 맞추기 </a>

- **코드의 형식을 깔끔하게 유지하는 것은 추후 유지보수나 확장성에 용이하다.**
- 파일 크기(행의 길이)는 크지 않아도 커다란 시스템을 구축할 수 있고 작아야 이해하기가 더 편하다.
- 세로 형식의 경우 서로 연관성이 없는 개념 같은 경우 빈 행으로 구분하는 것이 가독성에 좋다.
- 가로 형식은 파일의 크기와 똑같이 긴 행보다는 짧은 행을 더 선호한다.
- 가로 형식은 공백을 이용해서 느슨한 개념과 밀접한 개념을 표현한다.
- 가로 정렬은 구조를 강조하다가 오히려 의도를 가릴 수 있고 들여쓰기는 하는 것이 각 영역을 판단하는 데 좋다.
- 결국, 애플리케이션이 만들어지기까지에는 여러 사람이 이루어진 팀이 함께 진행하기 때문에 그 팀의 룰을 따르는 게 좋다.

## <a name = '5'> 6장. 객체와 자료 구조 </a>

- 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하면서 새 객체 타입을 추가하기는 쉽지만, 기존 객체에 새 동작을 추가하기는 어렵다.
- 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.(디미터 법칙)
- 시스템을 구현할 때, 추가하고자 하는 것이 객체인지 동작인지에 따라 최적인 해결책을 선택하는 것이 좋다.

## <a name = '6'> 7장. 오류 처리 </a>

- 오류 처리는 중요하다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다.  
- 오류 코드보다 예외를 사용하면 보다 깨끗한 코드를 작성할 수 있다.
- `try-catch-finally`를 사용하여 프로그램 상태를 일관성 있게 유지한다.
- 예외를 던질 때는 오류 메시지에 정보를 담아 함께 던져 오류가 발생한 원인과 위치를 찾기 쉽게 한다.
- 때로는 정상 흐름을 정의하여 클라이언트가 예외 상황을 처리할 필요가 없도록 할 수 있다. 

## <a name = '7'> 8장. 경계 </a>

- 외부 코드를 가져와 사용할 때 우리 코드에 깔끔하게 통합해야 한다.  
- `Map`과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환 값으로 사용하지 않는다.
- 외부 코드를 익히거나 통합하는 것은 어렵다. 대신 우리 쪽 코드를 작성해 간단한 테스트 케이스를 작성해 외부 코드를 익히기는 쉽다. 이를 `학습 테스트`라 한다.  
- 학습 테스트에 드는 비용은 없다. 필요한 지식만 확보하면 되므로 이해도를 높여주고, 투자하는 노력보다 얻는 성과가 더 크다.
- 경계에 위치하는 코드는 깔끔히 분리하고, 기대치를 정의하는 테스트 케이스도 작성한다.  
- 통제 불가능한 외부 패키지 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다.
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.

## <a name = '8'> 9장. 단위 테스트 </a>

- TDD의 세 가지 법칙
    1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
    1. 컴파일은 실패하지 않으면서 실패하는 정도로만 단위 테스트를 작성한다.
    1. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- TDD 방식을 따르게 되면 모든 기능을 테스트하는 테스트 케이스가 나오게 된다. (테스트 커버리지 100%)
- 테스트 구조는 BUILD-OPERATE-CHECK(given-when-then) 패턴과 같은 테스트 구조가 적합하다.
- 테스트 환경과 실제 배포 환경은 다르기에 실제 코드만큼이나 효율적일 필요는 없다. (이중 표준)
- 테스트 당 assert 하나만 사용하는 것이 결론이 하나라는 뜻이므로 코드를 이해하기 쉽다. (최소한 assert문)
- 깨끗한 테스는 FIRST 규칙을 따른다.
    1. FAST : 테스트는 빨라야 한다.
    1. Independent : 테스트는 서로 의존해서는 안 된다.
    1. Repeatable : 어떤 환경에서도 테스트가 동작할 수 있어야 한다.
    1. Self-Validating : 결과는 성공/실패만 존재해야 한다.
    1. Timely : 테스트하려는 실제 코드를 구현하기 직전에 구현한다.

## <a name = '9'> 10장. 클래스 </a>

- **클래스는 함수와 마찬가지로 작아야 하는 것이 기본 규칙이다.**
- 클래스는 변경하는 이유가 단 한 가지여야 한다. (SRP)
- 클래스에 인스턴스 변수는 적어야 하며, 각 클래스 메서드는 인스턴스 변수를 하나 이상 사용해야 좋다.
    - 일반적으로 메서드가 변수를 많이 사용할수록 응집도가 높다.
    - 어떤 특정 메서드만이 사용하는 인스턴스 변수가 많아진다면 리팩토링의 신호이다.
- 대다수의 시스템에는 지속적인 변경이 일어나므로 변경하기 쉬운 클래스를 만들어줘야 한다.
    - 인터페이스, 추상 클래스를 이용하여 관계를 느슨하게 하여 변경에 미치는 영향을 최소화한다.

## <a name = '10'> 11장. 시스템 </a>

- 소프트웨어 시스템은 준비 과정과 런타임 로직을 분리해야 한다.
    - 생성 과정 : 애플리케이션 객체를 제작하고 의존성을 서로 연결하는 과정
    - 런타임 로직 : 비즈니스 로직
- **의존성 주입은 생성과 사용을 분리하는 강력한 메커니즘이다.**
- 처음부터 큰 시스템은 존재하지 않고 점차 늘려갈 뿐이다.
    - TDD로 얻어진 코드는 시스템을 조정하고 확장하기 쉽게 만들어준다.
- 횡단 관심사를 통해 일부 영역을 적절하게 모듈화할 수 있다.
    - 자바 프록시
    - 순수 자바 AOP 프레임워크
    - AspectJ

## <a name = '11'> 12장. 창발성 </a>

- 우수한 설계를 하기 위한 네 가지 규칙
    1. 모든 테스트를 실행한다.
    1. 중복을 없앤다.
    1. 프로그래머 의도를 표현한다.
    1. 클래스와 메서드 수를 최소로 줄인다.

## <a name = '12'> 13장. 동시성 </a>

- 동시성 코드는 제대로 작성하기 어렵다. 다중 스레드 코드를 작성한다면 각별히 깨끗하게 코드를 짜야 한다. 
- SRP를 준수한다. POJO를 사용해 스레드를 아는 코드와 모르는 코드를 분리한다. 스레드 코드를 테스트할 때는 전적으로 스레드만 테스트한다.  
- 동시성 오류를 일으키는 잠정적인 원인을 철저히 이해한다. 또한 사용하는 라이브러리와 기본 알고리즘을 이해한다.  
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.  
- 초반에 드러나는 일회성 문제를 무시하지 않는다. 스레드 코드는 최대한 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트한다.
- 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아진다.  
- 스레드 코드는 출시하기 전까지 최대한 오랫동안 돌려봐야 한다.
