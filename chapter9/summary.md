# 9장. 단위 테스트 p.154

# 목차

1. [TDD 법칙 세 가지](#1)
1. [깨끗한 테스트 코드 유지하기](#2)
   1. [테스트는 유연성, 유지보수성, 재사용성을 제공한다](#2-1)
1. [깨끗한 테스트 코드](#3)
   1. [도메인에 특화된 테스트 언어](#3-1)
   1. [이중 표준](#3-2)
1. [테스트 당 assert 하나](#4)
   1. [테스트 당 개념 하나](#4-1)
1. [F.I.R.S.T](#5)
   1. [빠르게(Fast)](#5-1)
   1. [독립적으로(Independent)](#5-2)
   1. [반복가능하게(Repeatable)](#5-3)
   1. [자가검증하는(Self-Validating)](#5-4)
   1. [적시에(Timely)](#5-5)
1. [결론](#6)

## <a name = '1'> TDD 법칙 세 가지 p.155 </a>

- 세 가지 법칙
   - 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
   - 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
   - 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- 다음과 같이 이행하면 테스트 코드와 실제 코드가 함께 나오게 된다. 
- 이렇게 하면 수백, 수천 개의 테스트 케이스가 나오게 되어 실제 코드를 전부 테스트하는 테스트 케이스가 나온다.
- 하지만 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

## <a name = '2'> 깨끗한 테스트 코드 유지하기 p.156 </a>

- 테스트 코드를 작성하지 않는 것보다 더럽더라도 테스트 코드가 있는 편이 좋다고 판단했을지 모른다. 하지만 **지저분한 테스트 코드는 테스트를 안 하는 것보다 더 좋지 않다.**
- 문제점은 실제 작성한 코드가 진화하게 되면 테스트 코드도 변해야 한다. 하지만 **테스트 코드가 지저분할수록 변경하는 시간이 더 오래 걸리게 되고 결국 실제 코드 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 오래 걸릴 것이다.** 
- 결국 유지 보수하는 비용이 늘어나 테스트 슈트를 폐기해야 하는 상황에 이르게 된다.
- 하지만 **테스트 슈트가 없으면 개발자는 자신이 짠 코드가 제대로 작동하는 알 수 없고 결함률이 늘어나게 된다.** 
- 이 말의 결론은 테스트 코드 또한 실제 코드 못지않게 중요하다는 것이다. **테스트 코드는 사고와 설계와 주의가 필요하며 실제 코드 못지않게 깨끗하게 작성해야 한다.**

> **테스트 케이스, 테스트 유닛, 테스트 슈트**
>
> 테스트 케이스 : 테스트 코드 하나하나를 의미
>
> 테스트 유닛 : 테스트 케이스의 집합
>
> 테스트 슈트 : 테스트 유닛의 집합
> 
> 즉, 스코프(Scope) : 케이스 < 유닛 < 슈트

### <a name = '2-1'> 테스트는 유연성, 유지보수성, 재사용성을 제공한다 </a>

- 코드의 유연성, 유지보수성, 재사용성을 제공하는 버팀목은 바로 **단위 테스트**이다. 이유는 테스트 케이스가 있으면 변경이 두렵지 않기 때문이다. 
- 아무리 설계를 잘 나누고 구현을 했다고 하더라도 **테스트 케이스가 없으면 개발자는 변경을 주저하고 버그가 숨어들까 두려울 수밖에 없다.**
- 하지만 테스트 케이스가 있다면 공포는 사라진다. 테스트 커버리지는 높을수록 공포가 줄어들고 반면에 아키텍처 설계가 부실하고 구현이 엉망이라도 변경하는데 오히려 안심하고 해당 코드를 개선해나갈 수 있을 것이다.

> **테스트 커버리지**
> 
> 테스트 케이스가 얼마나 충족되었는지를 나타내는 지표, 테스트를 진행하였을 때 '코드 자체가 얼마나 실행되었느냐'는 것이고 이를 수치를 통해 확인

## <a name = '3'> 깨끗한 테스트 코드 p.158 </a>

- 깨끗한 코드를 만들기 위해서 필요한 것은 **가독성**이다. 명료성, 단순성, 풍부한 표현력이 필요하며 테스트 코드는 최소한의 표현으로 많은 것을 나타내야 한다.

```java
public void testGetPageHierarchyAsWml() throws Exception {
	makePages("PageOne", "PageOne.ChildOne", "PageTwo");

	submitRequest("root", "type:pages");

	assertResponseIsXML();
	assertResponseContains(
		"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
	);
}
```

- BUILD-OPERATE-CHECK 패턴과 같은 테스트 구조가 적합하다.

1. 테스트의 자료를 만든다.
2. 테스트 자료를 조작한다.
3. 조작한 테스트 자료의 결과가 올바른지 확인한다.

- 잡다하고 세세한 코드를 거의 다 없앴다는 사실에 주목해야 하고 테스트 코드는 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다.

### <a name = '3-1'> 도메인에 특화된 테스트 언어 </a>

- 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하면 테스트 코드를 짜기도 읽기도 쉬워진다. 
- 흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현해서 사용하면 좋다.

### <a name = '3-2'> 이중 표준 </a>

- 테스트 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 다르다. 단순, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.

```java
@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals("HBchl", hw.getState());
}
```

- 위 소스 코드는 문자열이 대문자이면 on 소문자이면 off라는 뜻이고 문자 순서대로 {heater, blower, cooler, hi-temp-alarm, lo-temp-alarm} 순서이다. 
- 비록 **위 방식이 그릇된 정보를 피하라는 규칙의 위반에 가깝지만 여기서는 적절**하다. 
- 왜냐하면 의미를 안다면 눈길이 문자열에 따라 움직이며 결과를 재빨리 판단할 수 있기 때문이다.

```java
public String getState() {
	String state = "";
	state += heater ? "H" : "h";
	state += blower ? "B" : "b";
	state += cooler ? "C" : "c";
	state += hiTempAlarm ? "H" : "h";
	state += loTempAlarm ? "L" : "l";
	return state;
}
```

- 위 실제 코드에서는 StringBuffer가 더 효율적이다. 하지만 StringBuffer는 보기에 흉하다. 
- 실제 코드였다면 컴퓨터 자원과 메모리가 제한적일 가능성이 높아서 StringBuffer를 사용해야하지만 테스트 환경은 자원이 제한적일 가능성이 낮다. 
- 그렇기에 전혀 문제없는 방식이므로 String을 사용하였다.

## <a name = '4'> 테스트 당 assert 하나 p.164 </a>

- JUnit으로 테스트 코드를 짤 때는 함수마다 assert 문을 단 하나만 사용해야 한다는 학파가 있고 가혹하다고 여길지는 모르지만 확실한 장점이 있다. 
- **assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.**
- 두 개 이상의 assert를 여러 개의 테스트 케이스로 쪼개려고 보면 읽기는 쉬워지지만 중복되는 코드가 많이 발생하게 된다. 
- 해결하는 방법
   1. Template method pattern
      - given/when 부분을 부모 클래스에 두고 then을 자식 클래스에 두는 방식
   2. Before 어노테이션 함수
      - Before 어노테이션 함수에 given/when 부분을 넣고 각 테스트케이스 Test 함수에 then 부분을 넣는 방법
- 하지만 결국 이런 방법들을 적용하다 보면 배보다 배꼽이 더 커지는 경우가 있을 수 있어서 여러 개를 넣는 게 더 나은 편이 발생한다.
- 결론은 단일 assert문 규칙은 훌륭한 지침이고 최대한 단일 assert문 규칙을 지키며 assert문의 개수를 최대한 줄여야 하는 것이 좋다는 생각이다.

### <a name = '4-1'> 테스트 당 개념 하나 </a>

- 테스트 함수마다 한 개념만 테스트하라는 규칙이 더 나을 수도 있다.

```java
public void testAddMonths() {
    SerialDate d1 = SerialDate.createInstance(31, 5, 2004);

    SerialDate d2 = SerialDate.addMonths(1, d1);
    assertEquals(30, d2.getDayOfMonth());
    assertEquals(6, d2.getMonth());
    assertEquals(2004, d2.getYYYY());

    SerialDate d3 = SerialDate.addMonths(2, d1);
    assertEquals(31, d3.getDayOfMonth());
    assertEquals(7, d3.getMonth());
    assertEquals(2004, d3.getYYYY());

    SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1));
    assertEquals(30, d2.getDayOfMonth());
    assertEquals(7, d2.getMonth());
    assertEquals(2004, d2.getYYYY());
}
```

- 위 예제는 독자적인 개념 세 개를 한 곳에서 테스트하므로 세 개의 테스트 케이스로 쪼개는 것이 옳다.

1. 2004년에 5월 +1 달에 년/월/일이 맞게 갱신되었는지
2. 2004년에 5월 +2 달에 년/월/일이 맞게 갱신되었는지
3. 2004년에 5월 +1 +1 달에 년/월/일이 맞게 갱신되었는지

- 위 예제는 assert문을 여러 개 쓴 것이 문제가 아니고 여러 개념을 한 곳에서 테스트한 것이 문제이다.
- 앞에서 말한 것과 포함하여 가장 좋은 규칙은 **개념 당 assert 문 수를 최소로 줄여라**와 **테스트 함수 하나는 개념 하나만 테스트하라**이다.

## <a name = '5'> F.I.R.S.T p.167 </a>

- 깨끗한 테스트는 다음 다섯 가지 규칙을 따른다.

### <a name = '5-1'> 빠르게(Fast) </a>

- **테스트는 빨라야 한다.** 테스트가 느리면 자주 돌릴 수 없고 그렇기에 자주 돌리지 못하여 초반에 문제를 빠르게 찾아내 고치지 못한다.

### <a name = '5-2'> 독립적으로(Independent) </a>

- **각 테스트는 서로 의존하면 안 된다.** 각 테스트는 독립적으로 어떤 순서로 실행해도 상관없어야 한다. 
- 서로가 의존하게 된다면 하나가 실패하면 나머지도 잇달아 실패하게 되어 원인을 진단하기 어려워진다.

### <a name = '5-3'> 반복가능하게(Repeatable) </a>

- 테스트는 어떤 환경에서도 반복 가능해야 한다. **어떠한 환경에서도 테스트가 작동**될 수 있어야 한다. 
- 그렇지 않으면 테스트가 실패할 이유를 둘러낼 변명이 생기게 된다.

### <a name = '5-4'> 자가검증하는(Self-Validating) </a>

- 테스트는 boolean 값으로 결과를 내야 한다. **성공 아니면 실패**이다. 
- 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적으로 된다.

### <a name = '5-5'> 적시에(Timely) </a>

- 테스트는 적시에 작성해야 한다. 단위 테스트는 **테스트하려는 실제 코드를 구현하기 직전에 구현**한다. 
- 실제 코드를 구현한 다음에 테스트 코드를 만들게 되면 실제 코드가 테스트하기 어렵다는 사실, 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.

## <a name = '6'> 결론 </a>

- 테스트 코드는 실제 코드만큼이나 프로젝트 건강에 중요하다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 
- 그러므로 테스트 코드는 지속해서 깨끗하게 관리하자.